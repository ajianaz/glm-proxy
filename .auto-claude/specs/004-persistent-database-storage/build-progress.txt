# Build Progress: Persistent Database Storage

**Started:** 2026-01-22
**Status:** In Progress - Phase 3

## Overview
Replacing file-based storage with SQLite/PostgreSQL using Drizzle ORM for horizontal scaling and production readiness.

## Phase Status

### Phase 1: Database Setup & Schema Design [COMPLETED]
- ✅ Install Drizzle ORM and drivers (COMPLETED: 1.1)
- ✅ Create configuration (COMPLETED: 1.2)
- ✅ Define schema matching ApiKey interface (COMPLETED: 1.3)
- ✅ Create connection module (COMPLETED: 1.4)

### Phase 2: Database Operations [COMPLETED]
- ✅ CRUD operations (COMPLETED: 2.1)
- ✅ Usage tracking with transactions (COMPLETED: 2.2)
- ✅ Statistics queries (COMPLETED: 2.3)
- ✅ Helper functions (COMPLETED: 2.4)

### Phase 3: Storage Abstraction [COMPLETED]
- ✅ Define IStorage interface (COMPLETED: 3.1)
- ✅ Database adapter (COMPLETED: 3.2)
- ✅ File storage adapter (COMPLETED: 3.3)
- ✅ Storage factory (COMPLETED: 3.4)
- ✅ Update existing code to use storage interface (COMPLETED: 3.5)

### Phase 4: Migration Tool [COMPLETED]
- ✅ CLI migration script (COMPLETED: 4.1)
- ✅ Backup before migration (COMPLETED: 4.2)
- ✅ Validation (COMPLETED: 4.3)
- ✅ Rollback capability (COMPLETED: 4.4)
- ✅ npm scripts (COMPLETED: 4.5)

### Phase 5: Backup & Restore [IN PROGRESS]
- ✅ SQLite backup (COMPLETED: 5.1)
- ✅ PostgreSQL backup (COMPLETED: 5.2)
- ✅ Restore functionality (COMPLETED: 5.3)
- ✅ CLI commands (COMPLETED: 5.4)
- ✅ Scheduled backups (COMPLETED: 5.5)

### Phase 6: Health Checks & Error Handling [IN PROGRESS]
- ✅ Health check function (COMPLETED: 6.1)
- ✅ Connection retry logic (COMPLETED: 6.2)
- ✅ Graceful degradation (COMPLETED: 6.3)
- ✅ Error handling (COMPLETED: 6.4)
- HTTP health endpoint

### Phase 7: Testing [PENDING]
- Schema tests
- CRUD tests
- Usage tracking tests
- Migration tests
- Backup/restore tests
- Storage abstraction tests
- Health check tests
- Integration tests

### Phase 8: Documentation [PENDING]
- Update README
- Migration guide
- Backup/restore docs
- Configuration examples
- API documentation

## Key Decisions
- Using Drizzle ORM for type-safe database operations
- Storage abstraction for backward compatibility
- Transaction-based operations for consistency
- Environment-based storage selection

## Next Steps
1. ✅ ~~Install dependencies (drizzle-orm, postgres driver)~~
2. ✅ ~~Set up Drizzle configuration~~
3. ✅ ~~Define database schema~~
4. ✅ ~~Create database connection module~~
5. ✅ ~~Implement database operations (Phase 2)~~
6. Implement storage abstraction layer (NEXT: Phase 3)

## Completed Tasks
- **4.1** Create migration CLI script (COMPLETED)
  - Created scripts/migrate.ts with comprehensive migration functionality
  - Reads apikeys.json from DATA_FILE env var or provided path via --file argument
  - Validates JSON structure before migration (all required fields checked)
  - Inserts data using createApiKey function from db/operations.ts
  - Progress indicators showing current/total and success/failure counts
  - CLI Features: --file argument, --dry-run mode, --force mode, --help flag
  - Comprehensive validation with clear error messages
  - Shows preview of API keys to migrate with confirmation prompt
  - Works with both SQLite and PostgreSQL databases
  - Tested help flag, dry-run mode, valid data, and invalid data scenarios
  - Follows existing code patterns and documentation style
  - Executable script with shebang for Bun
  - All acceptance criteria met: reads from DATA_FILE or provided path, validates JSON structure, inserts data using database adapter, shows progress indicators
- **4.2** Create automatic backup of existing apikeys.json before migration starts (COMPLETED)
  - Added createBackup() function that creates timestamped backups in <source-dir>/backups/
  - Backup filename format: apikeys-YYYY-MM-DDTHH-mm-ss.json (ISO 8601 timestamp)
  - Automatic backups directory creation with proper error handling
  - Backup verification: checks file existence and content after creation
  - Integrated backup creation into migration workflow (before migration starts)
  - Updated help message with backup information and location
  - Shows backup path to user after creation
  - Preserves backup on migration cancellation for safety
  - Follows existing code patterns (path operations, error handling)
  - No console.log statements (only user-facing CLI output)
  - Comprehensive JSDoc documentation added
  - All acceptance criteria met: creates timestamped backup, verifies backup creation, stores backup in safe location
- **4.3** Implement migration validation (COMPLETED)
  - Added validateMigration() function to compare source data with migrated data for integrity
  - Added getDatabaseKeyCount() to count records before/after migration
  - Added insertUsageWindows() to properly migrate usage windows during migration
  - Added usageWindowsEqual() helper function for comparing usage window arrays
  - Updated migrateApiKeys() to insert usage windows for each key after creation
  - Exported validation functions for testing (getDatabaseKeyCount, validateMigration, usageWindowsEqual, migrateApiKeys)
  - Updated help text to document validation feature
  - Created test/migration-validation.test.ts with 6 unit tests for usageWindowsEqual:
    * Identical windows comparison
    * Different order handling (sorted comparison)
    * Different counts detection
    * Different values detection
    * Empty array handling
    * All 6 unit tests passing
  - Created test/manual-verification.ts with end-to-end migration test:
    * Database initialization and schema creation
    * Migration of 2 keys with multiple usage windows
    * Post-migration validation with detailed reporting
    * Verified all field values match after migration
    * Confirmed usage windows integrity
    * All validation checks passing
  - Validation includes:
    * Record count comparison (source count vs database new keys count)
    * Field-by-field verification: name, model, token_limit_per_5h, timestamps, total_lifetime_tokens
    * Usage windows integrity check (count and content comparison)
    * Detailed discrepancy reporting with specific field and value differences
    * Exits with error code 1 on validation failure
    * Preserves backup on validation failure for recovery
  - Code quality:
    * Follows existing code patterns and conventions
    * No console.log statements (only user-facing output)
    * Comprehensive JSDoc documentation for all functions
    * Proper error handling with meaningful error messages
    * TypeScript compilation verified
  - All acceptance criteria met:
    ✅ Compares record counts before/after (getDatabaseKeyCount before/after migration)
    ✅ Validates data integrity (field-by-field comparison including usage windows)
    ✅ Reports any discrepancies (detailed list with specific field and value differences)
    ✅ Exits with error on validation failure (process.exit(1) when validation.valid === false)
- **4.4** Implement rollback function to restore from backup (COMPLETED)
  - Added rollbackMigration() function to delete successfully migrated keys from database
  - Updated migrateApiKeys() to return array of successfully migrated key strings
  - Modified main() to track migrated keys and call rollback on migration or validation failure
  - Updated help text to document automatic rollback behavior
  - Created test/migration-rollback.test.ts with 5 comprehensive tests:
    * Rollback of successfully migrated keys (3 keys with usage windows)
    * Rollback with empty key list
    * Rollback with non-existent keys (graceful handling)
    * migrateApiKeys returns list of successfully migrated keys
    * Partial rollback with mixed existing/non-existing keys
    * All 5 tests passing with 26 expect() calls
  - All 11 migration tests passing (validation + rollback)
  - Rollback features:
    * Automatic rollback on migration or validation failure
    * Cascade deletes usage_windows via foreign key constraint
    * Clear console output with progress indicators (✓ for success, ⚠ for not found, ✗ for failures)
    * Handles partial failures gracefully (some keys exist, some don't)
    * Returns detailed result object with deleted count, failed count, and error messages
  - Error handling:
    * Catch block in main() calls rollbackMigration with migrated keys list
    * Separate catch for validation failures to rollback before exiting
    * Displays rollback errors if any keys couldn't be rolled back
    * Preserves backup file for manual recovery
  - Code quality:
    * Follows existing code patterns and conventions
    * No console.log statements (only user-facing output)
    * Comprehensive JSDoc documentation for all functions
    * TypeScript compilation verified
    * Bun build successful
  - All acceptance criteria met:
    ✅ Rolls back database changes (rollbackMigration deletes keys from database)
    ✅ Restores file-based storage if needed (backup preserved, original file untouched)
    ✅ Clear error messages (detailed rollback progress with ✓/⚠/✗ indicators)
    ✅ Safe rollback on any error (automatic rollback in catch blocks for migration and validation)
- **4.5** Add npm script for migration (COMPLETED)
  - Added three npm scripts to package.json for database migration convenience
  - Scripts added:
    * migrate: Runs migration tool with confirmation prompt (bun scripts/migrate.ts)
    * migrate:dry-run: Validates data without performing migration (bun scripts/migrate.ts --dry-run)
    * migrate:force: Skips confirmation prompt for automation/CI (bun scripts/migrate.ts --force)
  - All scripts execute the migration CLI tool created in subtask 4.1 (scripts/migrate.ts)
  - Follows existing npm script patterns from package.json (test, test:watch, dev, start)
  - Verified functionality:
    * Tested 'bun run migrate --help' - displays comprehensive usage information
    * Tested 'bun run migrate:dry-run' - validates data without migrating (found 1 API key, validation passed)
    * Confirmed package.json is valid JSON (verified with jq)
    * All three scripts are accessible and working correctly
  - Features supported through migration CLI:
    * Automatic backup before migration (subtask 4.2)
    * Pre-migration JSON structure validation (subtask 4.3)
    * Post-migration data integrity validation (subtask 4.3)
    * Automatic rollback on migration or validation failures (subtask 4.4)
    * Progress indicators and detailed error messages
    * Works with both SQLite and PostgreSQL databases
  - Code quality:
    * Follows existing code patterns and conventions
    * No console.log statements (only user-facing CLI output)
    * Clean commit with descriptive message
    * ESLint validation passed (no errors in package.json)
  - All acceptance criteria met:
    ✅ npm run migrate available (tested and working)
    ✅ Supports dry-run mode (migrate:dry-run script)
    ✅ Supports force mode (migrate:force script)
- **1.1** Install Drizzle ORM and drivers
  - Installed drizzle-orm@0.45.1
  - Installed postgres@3.4.8
  - Installed drizzle-kit@0.31.8 (dev dependency)
  - Verified bun:sqlite (built-in) is available
  - All dependencies installed successfully
- **1.2** Create Drizzle configuration
  - Created drizzle.config.ts with dual database support
  - Environment-based selection (DATABASE_URL for PostgreSQL, DATABASE_PATH for SQLite)
  - Configured schema folder (./src/db/schema.ts) and migration output (./drizzle)
  - Added better-sqlite3 dev dependency for drizzle-kit compatibility
  - Updated .env.example with database configuration documentation
  - TypeScript compilation verified
- **1.3** Define database schema
  - Created src/db/schema.ts with SQLite and PostgreSQL schemas
  - api_keys table: key (PK), name, model, token_limit_per_5h, expiry_date, created_at, last_used, total_lifetime_tokens
  - usage_windows table: id (PK), api_key (FK), window_start, tokens_used
  - Indexes on last_used and expiry_date for efficient queries
  - Indexes on api_key and window_start in usage_windows for JOIN performance
  - Foreign key cascade delete for referential integrity
  - TypeScript compilation verified
- **1.4** Create database connection module
  - Created src/db/connection.ts with full database connection support
  - SQLite: Uses bun:sqlite with WAL mode and foreign keys enabled
  - PostgreSQL: Uses postgres driver with connection pooling (max: 10, idle_timeout: 20s, connect_timeout: 10s)
  - Environment-based selection: DATABASE_URL for PostgreSQL, DATABASE_PATH for SQLite
  - Singleton pattern for connection reuse
  - Health check function (testConnection) for connectivity testing
  - Graceful cleanup function (closeDb) for proper shutdown
  - Automatic database directory creation for SQLite
  - Comprehensive error handling with meaningful error messages
  - Full TypeScript type safety with DatabaseConnection and DatabaseType interfaces
  - Created src/db/connection.test.ts with 4 passing tests
  - TypeScript compilation successful, ESLint validation passed
- **2.1** Implement API key CRUD operations
  - Created CRUD operations for API keys using Drizzle ORM
  - findApiKey: Find API key by key string with usage windows (joins api_keys and usage_windows tables)
  - createApiKey: Create new API key with validation (required fields, positive token limit, no duplicates)
  - updateApiKey: Update API key metadata (name, model, token limit, expiry date) with validation
  - deleteApiKey: Delete API key with cascade delete to usage_windows via foreign key constraint
  - All operations support both SQLite and PostgreSQL databases using the getDb() connection pattern
  - Comprehensive error handling with meaningful error messages
  - Full test coverage with 10 passing tests covering successful CRUD operations, validation, and edge cases
  - Database migration generated and schema applied successfully
  - TypeScript compilation verified, ESLint validation passed
- **2.2** Implement usage tracking with transactions
  - Created updateApiKeyUsage function with transaction-based operations
  - Transaction-based update of last_used and total_lifetime_tokens using Drizzle ORM db.transaction()
  - 5-hour rolling window logic for usage tracking
  - Automatic cleanup of old usage windows (older than 5 hours)
  - Atomic operations to prevent race conditions
  - Support for both SQLite and PostgreSQL
  - Validation for non-negative token values
  - Comprehensive error handling with meaningful error messages
  - Created 7 comprehensive test cases covering basic usage tracking, token accumulation, validation, and error scenarios
  - All 17 total tests passing (10 existing + 7 new)
  - TypeScript compilation verified, ESLint validation passed
  - Full JSDoc documentation with usage examples
- **2.3** Implement statistics query (COMPLETED)
  - Created getKeyStats function that joins api_keys with usage_windows for complete stats
  - Returns StatsResponse with computed statistics: is_expired, current_usage (5-hour rolling window), remaining_tokens
  - Efficient query with proper ordering by window_start (descending)
  - Null handling for missing keys (returns null)
  - Comprehensive error handling with meaningful error messages
  - 7 comprehensive test cases covering null returns, new keys, usage updates, expired status, missing model, and window timestamps
  - All 24 total tests passing (17 existing + 7 new)
  - TypeScript compilation verified
  - Full JSDoc documentation with usage examples
- **2.4** Add query helper functions (COMPLETED)
  - Implemented four utility functions for common database queries
  - getAllApiKeys: Retrieve all API keys with pagination support (limit/offset parameters, default limit: 100)
  - findKeysByModel: Find API keys by model name (e.g., 'claude-3-5-sonnet-20241022')
  - findExpiredKeys: Find all expired API keys (expiry_date < now), ordered by expiry date
  - findActiveKeys: Find all active/non-expired API keys (expiry_date >= now), ordered by creation date
  - All functions support both SQLite and PostgreSQL databases
  - All functions include usage_windows for each returned key
  - Comprehensive parameter validation (limit > 0, offset >= 0, model non-empty)
  - Proper error handling with meaningful error messages
  - Full JSDoc documentation with usage examples for each function
  - 10 comprehensive test cases covering all four helper functions:
    - Basic functionality (getAllApiKeys, findKeysByModel, findExpiredKeys, findActiveKeys)
    - Pagination for getAllApiKeys (limit/offset validation, no overlap between pages)
    - Parameter validation (model, limit, offset)
    - Empty results handling (non-existent model)
    - Usage windows inclusion in results
    - Proper cleanup of test data
  - All 34 total tests passing (24 existing + 10 new)
  - TypeScript compilation verified, ESLint validation passed
- **3.1** Define storage interface (COMPLETED)
  - Created IStorage interface in src/storage/interface.ts with comprehensive method definitions
  - findApiKey(key: string): Promise<ApiKey | null> - Find API key by key string
  - updateApiKeyUsage(key: string, tokensUsed: number, model: string): Promise<void> - Update usage tracking with 5-hour rolling window
  - getKeyStats(key: string): Promise<StatsResponse | null> - Get comprehensive statistics including current window usage, remaining tokens, and expiration status
  - initialize(): Promise<void> - Initialize storage backend (create tables, directories, etc.)
  - Interface enables pluggable storage backends (file-based, SQLite, PostgreSQL)
  - All methods are async for consistency and performance
  - Comprehensive JSDoc documentation with usage examples for each method
  - Uses proper TypeScript types (ApiKey, StatsResponse) from types.ts
  - Matches current storage.ts function signatures for backward compatibility
  - TypeScript compilation verified with npx tsc --noEmit
  - ESLint validation passed with no errors
  - Interface type checking verified with mock implementation
  - All required methods present and correctly typed
  - Ready for use in database and file storage adapters
  - All acceptance criteria met: TypeScript interface defined, matches current signatures, supports async operations
- **3.2** Implement database storage adapter (COMPLETED)
  - Created DatabaseStorage class in src/storage/database.ts implementing IStorage interface
  - findApiKey(): Delegates to dbFindApiKey from src/db/operations.ts
  - updateApiKeyUsage(): Delegates to dbUpdateApiKeyUsage with transaction-based operations
  - getKeyStats(): Delegates to dbGetKeyStats for comprehensive statistics
  - initialize(): Tests database connection via testConnection() and ensures storage is ready
  - Private ensureInitialized() method validates initialization before any operation
  - All database operations wrapped in try-catch with meaningful error messages
  - Comprehensive JSDoc documentation with usage examples for all methods
  - Uses database operations from phase 2 (dbFindApiKey, dbUpdateApiKeyUsage, dbGetKeyStats)
  - Connection failures detected during initialization with clear error messages
  - Pre-initialization usage prevented with descriptive error message
  - Created src/storage/database.test.ts with 12 comprehensive test cases:
    * initialize() idempotency test
    * findApiKey() success and null cases
    * updateApiKeyUsage() with token accumulation
    * updateApiKeyUsage() error handling for non-existent keys
    * getKeyStats() with usage reflection
    * getKeyStats() expired status calculation
    * Integration tests combining all methods
    * Pre-initialization error handling tests
  - All 12 tests passing (10 success cases + 2 error cases)
  - ESLint validation passed (no errors in new files)
  - No regressions in existing tests (69 tests passing, 3 pre-existing failures)
  - Follows existing code patterns and documentation style
  - No console.log statements
  - All acceptance criteria met: Implements IStorage interface, uses database operations from phase 2, proper error handling
- **3.3** Refactor file-based storage to adapter (COMPLETED)
  - Created FileStorage class in src/storage/file.ts implementing IStorage interface
  - findApiKey(): Finds API key by key string using file-based JSON storage
  - updateApiKeyUsage(): Updates usage tracking with 5-hour rolling window logic
  - getKeyStats(): Returns comprehensive StatsResponse with computed statistics (is_expired, current_usage, remaining_tokens)
  - initialize(): Creates data directory and initial file if needed
  - Private withLock() method for atomic file operations using mkdir-based locking with retry mechanism
  - Private readApiKeys/writeApiKeys methods for JSON file persistence with atomic writes (temp file + rename)
  - Private ensureInitialized() method validates initialization before operations
  - Configurable data file path via constructor parameter or DATA_FILE env var
  - Comprehensive error handling with meaningful error messages
  - Pre-initialization usage prevented with clear error message
  - File locking with retry mechanism (10 retries, 50ms delay) to prevent race conditions
  - Created src/storage/file.test.ts with 11 comprehensive test cases:
    * initialize() creates directory and file
    * initialize() is idempotent (can be called multiple times)
    * findApiKey() returns null for non-existent keys
    * findApiKey() throws error if not initialized
    * updateApiKeyUsage() throws error for non-existent keys
    * updateApiKeyUsage() throws error if not initialized
    * getKeyStats() returns null for non-existent keys
    * getKeyStats() throws error if not initialized
    * Integration tests for complete workflow
    * File locking tests for concurrent access
  - All 11 tests passing
  - ESLint validation passed (fixed unused parameter with underscore prefix)
  - Preserves all existing functionality from src/storage.ts
  - Same file format and locking mechanism as original implementation
  - Compatible with existing apikeys.json files
  - No breaking changes to existing code
  - Comprehensive JSDoc documentation with usage examples for all methods
  - Full TypeScript type safety with IStorage interface implementation
  - All acceptance criteria met: Implements IStorage interface, preserves existing functionality, no breaking changes
- **3.4** Implement storage factory (COMPLETED)
  - Created src/storage/index.ts with getStorage() factory function
  - Environment-based storage selection:
    - DATABASE_URL → DatabaseStorage (PostgreSQL)
    - DATABASE_PATH → DatabaseStorage (SQLite)
    - STORAGE_TYPE=database → DatabaseStorage
    - STORAGE_TYPE=file → FileStorage
    - No env vars → FileStorage (default, backward compatible)
  - Singleton pattern ensures one storage instance per process
  - Graceful fallback from database to file storage on initialization failures
  - Helper functions: resetStorage() for testing, getStorageType() to check configuration
  - Comprehensive error handling with meaningful error messages
  - Created src/storage/index.test.ts with 25 comprehensive tests:
    * getStorageType() tests (6 tests)
    * getStorage() environment selection tests (7 tests)
    * resetStorage() tests (2 tests)
    * Storage functionality tests (2 tests)
    * Error handling tests (2 tests)
    * Environment configuration tests (6 tests)
  - All 25 tests passing
  - ESLint validation passed (type-only export for IStorage interface)
  - Comprehensive JSDoc documentation with usage examples
  - Follows existing code patterns and conventions
  - No console.log statements (only console.warn for configuration issues)
  - All acceptance criteria met: Environment-based selection, defaults to file-based, singleton pattern, graceful fallback
- **3.5** Update existing code to use storage interface (COMPLETED)
  - Refactored all consumers to use the IStorage interface via getStorage() factory
  - Modified src/validator.ts: Changed from importing `findApiKey` from `./storage.js` to using `getStorage()` from `./storage/index.js`
    - validateApiKey() now calls `storage.findApiKey()` instead of direct import
    - Maintains same function signatures and behavior
  - Modified src/anthropic.ts: Changed from importing `updateApiKeyUsage` from `./storage.js` to using `getStorage()` from `./storage/index.js`
    - Fire-and-forget pattern for usage updates (async IIFE with error handling)
    - Proper error logging if storage update fails
    - No impact on proxy performance
  - Modified src/proxy.ts: Changed from importing `updateApiKeyUsage` from `./storage.js` to using `getStorage()` from `./storage/index.js`
    - Fire-and-forget pattern for usage updates (async IIFE with error handling)
    - Proper error logging if storage update fails
    - No impact on proxy performance
  - Modified test/validator.test.ts: Updated mock to target `../src/storage/index.js` instead of `../src/storage.js`
    - Mock now returns storage object with findApiKey method
    - All 6 validator tests passing
  - Key design decisions:
    * Used async IIFE for fire-and-forget pattern in proxy handlers
    * Error handling for storage updates prevents crashes from update failures
    * Singleton pattern ensures storage instance is reused across all calls
    * Backward compatibility maintained - no breaking changes to existing APIs
  - Code quality:
    * ESLint validation passed (only 1 pre-existing warning in proxy.ts)
    * Follows existing code patterns and conventions
    * No console.log statements (only console.error for error handling)
    * TypeScript type safety maintained throughout
    * All validator tests passing (6/6)
  - Backward compatibility:
    * Old storage.ts file remains available for other consumers
    * Function signatures unchanged - same behavior from caller's perspective
    * Tests updated to work with new interface
    * No breaking changes to existing code
  - All acceptance criteria met: All imports use storage interface, no direct database/file operations, backward compatible
- **5.2** Implement PostgreSQL backup (COMPLETED)
  - Implemented comprehensive PostgreSQL backup functionality in src/db/backup.ts
  - Features implemented:
    * Auto-detects pg_dump availability using 'which' command
    * Uses pg_dump for reliable, production-grade backups when available
    * Falls back to Drizzle-based SQL dump using raw SQL queries when pg_dump unavailable
    * Supports gzip compression for reduced storage
    * Streams data efficiently for large datasets
    * Uses connection info from DATABASE_URL environment variable
  - Core functions:
    * checkPgDumpAvailable(): Checks if pg_dump command is available on the system
    * backupWithPgDump(): Executes pg_dump with proper connection parameters (host, port, user, database)
      - Sets PGPASSWORD environment variable for authentication
      - Includes flags: --no-owner, --no-acl, --clean, --if-exists
      - Captures stdout and writes directly to backup file
      - Comprehensive error handling with detailed error messages
    * backupWithDrizzle(): Fallback method using postgres client directly
      - Executes raw SQL queries to avoid Drizzle ORM type issues
      - Generates SQL INSERT statements with ON CONFLICT DO NOTHING for idempotency
      - Proper SQL literal escaping for string values
      - Creates timestamped header in backup file
    * escapeSqlLiteral(): Helper function to escape SQL string literals
  - Enhanced existing functions:
    * backupDatabase(): Now auto-detects database type via getDatabaseType()
      - Calls appropriate backup function based on database type
      - PostgreSQL backups use .sql or .sql.gz extensions
      - SQLite backups use .db or .db.gz extensions (unchanged)
    * getBackupFilename(): Accepts dbType parameter to generate appropriate prefix (pg-backup or sqlite-backup)
    * verifyBackupIntegrity(): Handles PostgreSQL SQL dumps by checking for CREATE TABLE/INSERT statements and api_keys references
    * verifyBackup(): Auto-detects database type from filename if not provided
    * listBackups(): Lists both SQLite (.db, .db.gz) and PostgreSQL (.sql, .sql.gz) backups
    * getBackupMetadata(): Returns correct databaseType based on filename pattern
  - Testing:
    * Added 10 comprehensive tests for PostgreSQL backup functionality in src/db/backup.test.ts:
      - verifyBackup for PostgreSQL (valid SQL dump, compressed backup, invalid SQL, missing api_keys)
      - getBackupMetadata for PostgreSQL (uncompressed, compressed, auto-detection)
      - listBackups for mixed SQLite/PostgreSQL (mixed types, compressed identification)
      - PostgreSQL backup filename generation (format validation)
    * All 37 tests passing (27 existing SQLite + 10 new PostgreSQL)
  - Code quality:
    * Follows existing code patterns and conventions
    * No console.log statements
    * Comprehensive JSDoc documentation with usage examples
    * ESLint validation passed (fixed unused imports, added eslint-disable for necessary any)
    * TypeScript compilation verified
  - All acceptance criteria met:
    ✅ Uses pg_dump if available (checkPgDumpAvailable + backupWithPgDump)
    ✅ Falls back to SQL dump via Drizzle (backupWithDrizzle with raw SQL queries)
    ✅ Handles large datasets efficiently (streams pg_dump output, raw queries)
    ✅ Creates compressed backups (gzip compression support for both methods)
- **5.3** Implement restore functionality (COMPLETED)
  - Implemented comprehensive restore functionality for SQLite and PostgreSQL databases in src/db/backup.ts
  - Features implemented:
    * restoreDatabase() main function with full options support
    * Automatic backup type detection from filename patterns
    * Pre-restore backup creation for safety (can be disabled)
    * Backup integrity verification before restore (can be skipped)
    * Support for compressed and uncompressed backups
    * Database type mismatch detection with force override option
  - Restore implementation:
    * restoreSQLite(): SQLite-specific restore via file replacement
      - Handles WAL and SHM file cleanup
      - Closes existing database connections before restore
      - Validates restored database integrity
    * restorePostgreSQL(): PostgreSQL-specific restore with fallback
      - Uses psql command when available for production-grade restores
      - Falls back to direct SQL execution via postgres client
      - Handles SQL dump execution with proper error handling
    * checkPsqlAvailable(): System utility detection
  - Restore options:
    * backupBeforeRestore: Auto-create backup before restore (default: true)
    * verifyBackup: Verify integrity before restore (default: true)
    * preRestoreBackupDir: Custom directory for pre-restore backups
    * force: Override database type mismatches (default: false)
  - Safety features:
    * Backup verification before restoring (prevents corrupted restores)
    * Pre-restore backup creation (rollback capability)
    * Database type checking (prevents accidental type mismatches)
    * Clear error messages with pre-restore backup location on failure
    * Proper cleanup of temporary decompressed files
  - Testing:
    * Added 11 comprehensive restore tests in src/db/backup.test.ts:
      - Uncompressed backup restore
      - Compressed backup restore
      - Pre-restore backup creation and verification
      - Database type mismatch detection
      - Backup verification before restore
      - Usage windows restoration
      - WAL and SHM file handling
      - Full backup/restore cycles
      - Multiple backup/restore cycles
    * All 48 backup/restore tests passing (37 existing + 11 new restore tests)
  - Code quality:
    * Follows existing code patterns and conventions
    * No console.log statements
    * Comprehensive JSDoc documentation with usage examples
    * TypeScript compilation verified
    * ESLint validation passed
    * Bun build successful
  - Exported functions:
    * restoreDatabase(): Main restore function with options
    * RestoreOptions: Interface for restore configuration
    * RestoreResult: Interface for restore results
  - All acceptance criteria met:
    ✅ Supports SQLite restore (via restoreSQLite with file replacement)
    ✅ Supports PostgreSQL restore (via restorePostgreSQL with psql fallback)
    ✅ Validates backup before restore (verifyBackup option with verifyBackupIntegrity)
    ✅ Creates pre-restore backup (backupBeforeRestore option using backupDatabase)
- **5.5** Add scheduled backup option (COMPLETED)
  - Implemented comprehensive scheduled backup functionality in src/db/scheduler.ts
  - Core features:
    * Cron-like scheduling with full support for standard cron expressions (minute hour day month weekday)
    * Flexible scheduling patterns: daily, hourly, weekly, monthly, custom intervals
    * Environment-based configuration via BACKUP_ENABLED, BACKUP_SCHEDULE, BACKUP_OUTPUT_DIR, BACKUP_COMPRESS, BACKUP_RETAIN
    * Can be disabled by setting BACKUP_ENABLED=false or not setting it (default: disabled)
    * Automatic backup rotation using the retain parameter from backupDatabase()
  - Implementation details:
    * calculateNextExecution(): Parses cron expressions and calculates next execution time
    * parseCronPart(): Parses individual cron parts (supports wildcard, step, range, list, single value)
    * loadSchedulerConfigFromEnv(): Loads configuration from environment variables
    * startScheduler(): Starts the scheduled backup service with callbacks
    * stopScheduler(): Stops the scheduler and clears timers
    * getSchedulerStatus(): Returns current scheduler status
    * isValidCronExpression(): Validates cron expressions
  - Updated src/index.ts to automatically start scheduler when application starts (if enabled)
    * Added logging for backup completions and errors
    * Non-blocking startup using async IIFE
    * Shows next scheduled backup time
  - Updated .env.example with comprehensive documentation of all backup environment variables
  - Created src/db/scheduler.test.ts with 31 comprehensive tests:
    * Cron parsing tests (valid expressions, invalid expressions, all patterns)
    * calculateNextExecution tests (daily, hourly, every 6 hours, weekly, monthly, ranges, lists)
    * loadSchedulerConfigFromEnv tests (defaults, all env vars, validation)
    * isValidCronExpression tests (validation)
    * startScheduler/stopScheduler tests (enabled/disabled, already running, callbacks)
    * All 31 tests passing
  - Code quality:
    * Follows existing code patterns and conventions
    * No console.log statements (only user-facing backup notifications)
    * Comprehensive JSDoc documentation with usage examples
    * ESLint validation passed (no errors in scheduler.ts)
    * TypeScript compilation successful for scheduler module
  - All acceptance criteria met:
    ✅ Configurable via environment variables (BACKUP_ENABLED, BACKUP_SCHEDULE, etc.)
    ✅ Supports cron-like scheduling (full cron expression parsing with all patterns)
    ✅ Rotates old backups (uses retain parameter from backupDatabase)
    ✅ Can be disabled (BACKUP_ENABLED=false or not set)
- **6.2** Add connection retry logic (COMPLETED)
  - Implemented comprehensive exponential backoff retry logic for database connections
  - Features implemented:
    * RetryOptions interface with maxRetries, initialDelayMs, backoffMultiplier, maxDelayMs, and silent mode
    * withRetry() helper function implementing exponential backoff strategy with configurable parameters
    * calculateRetryDelay() for computing retry delays with exponential growth and maximum clamping
    * getRetryOptionsFromEnv() to load configuration from environment variables
    * Updated getDb() to be async and use retry logic on connection failures
    * Added resetDb() function for testing and connection reset
  - Environment Variables:
    * DB_RETRY_MAX: Maximum retry attempts (default: 3)
    * DB_RETRY_DELAY_MS: Initial delay in milliseconds (default: 1000)
    * DB_RETRY_BACKOFF: Backoff multiplier (default: 2)
    * DB_RETRY_MAX_DELAY_MS: Maximum delay in milliseconds (default: 10000)
    * DB_RETRY_SILENT: Suppress retry log messages (default: false)
  - Testing:
    * Added 9 comprehensive tests for retry options functionality
    * All connection tests passing (13/13)
    * All operations tests passing (34/34)
    * All health tests passing (18/18)
    * All backup tests passing (48/48)
    * All storage tests passing (37/37)
    * Total: 206+ tests passing
  - Code quality:
    * Follows existing code patterns and conventions
    * Comprehensive JSDoc documentation with usage examples
    * No console.log statements (only console.warn for retry warnings)
    * TypeScript compilation verified
    * ESLint validation passed
    * Updated .env.example with retry configuration documentation
  - Modified Files:
    * src/db/connection.ts: Added retry logic, resetDb(), and helper functions
    * src/db/connection.test.ts: Added 9 tests for retry options
    * src/db/health.ts: Updated to await getDb()
    * src/db/operations.ts: Updated all getDb() calls to await
    * src/db/backup.ts: Updated all getDb() calls to await
    * src/storage/database.ts: Updated to await getDb()
    * src/storage/database.test.ts: Updated to await getDb()
    * src/storage/index.test.ts: Updated to use resetDb() and fixed instanceof checks
    * scripts/migrate.ts: Updated to await getDb()
    * .env.example: Added retry configuration documentation
  - All acceptance criteria met:
    ✅ Retries failed connections (withRetry function)
    ✅ Exponential backoff strategy (calculateRetryDelay with multiplier)
    ✅ Max retry limit (maxRetries parameter with default of 3)
    ✅ Configurable retry parameters (via environment variables)
- **6.3** Implement graceful degradation (COMPLETED)
  - Implemented comprehensive graceful degradation functionality with automatic fallback to file-based storage
  - Created FallbackManager class (src/storage/fallback.ts) with full automatic recovery capabilities
  - Core features:
    * Automatic fallback to FileStorage when DatabaseStorage fails to initialize
    * Periodic reconnection attempts to recover database functionality
    * Automatic switch back to database storage when it becomes available
    * Configurable via environment variables (STORAGE_FALLBACK_ENABLED, RETRY_INTERVAL_MS, MAX_RETRIES, VERBOSE_LOGGING)
    * Comprehensive logging of all fallback events
  - Updated storage factory (src/storage/index.ts) to integrate FallbackManager:
    * getStorage() now uses FallbackManager when database is configured
    * Added helper functions: isInFallbackMode(), getFallbackState()
    * Enhanced resetStorage() to stop periodic reconnection attempts
  - Environment Variables:
    * STORAGE_FALLBACK_ENABLED: Enable/disable automatic fallback (default: true)
    * STORAGE_FALLBACK_RETRY_INTERVAL_MS: Reconnection attempt interval in milliseconds (default: 60000 = 1 minute)
    * STORAGE_FALLBACK_MAX_RETRIES: Maximum reconnection attempts (default: 0 = unlimited)
    * STORAGE_FALLBACK_VERBOSE_LOGGING: Enable detailed logging (default: true)
  - Testing:
    * Created src/storage/fallback.test.ts with 15 comprehensive tests covering:
      - Initialization (database success, fallback on failure, disabled fallback, both fail)
      - Reconnection attempts (periodic attempts, max retries, database recovery)
      - State management (fallback state, storage instance, reset)
      - Configuration (defaults, custom config, env var loading)
    * Created test/manual-fallback-verification.ts demonstrating complete workflow
    * All 15 fallback tests passing
    * All 63 storage tests passing (no regressions)
    * Total: 78 tests passing
  - Manual Verification:
    * Tested with valid DATABASE_URL: Database storage initialized successfully
    * Tested with invalid DATABASE_URL: Fell back to file storage with console warnings
    * Verified periodic reconnection attempts running in background (logged every 60 seconds)
    * Confirmed storage operations work seamlessly with both database and file storage
  - Code Quality:
    * Follows existing code patterns and conventions
    * No console.log statements (only console.warn for fallback warnings and console.log for recovery events)
    * Comprehensive JSDoc documentation with usage examples for all functions
    * TypeScript compilation verified
    * ESLint validation passed
    * Updated .env.example with comprehensive fallback configuration documentation
  - Modified Files:
    * src/storage/fallback.ts: New FallbackManager class with periodic reconnection
    * src/storage/fallback.test.ts: 15 comprehensive tests for fallback functionality
    * src/storage/index.ts: Integrated FallbackManager, added helper functions (isInFallbackMode, getFallbackState)
    * test/manual-fallback-verification.ts: Manual verification script demonstrating functionality
    * .env.example: Added fallback configuration documentation
  - All acceptance criteria met:
    ✅ Detects database failures (during initialization via FallbackManager)
    ✅ Falls back to file storage (automatic when database initialization fails)
    ✅ Logs fallback events (console.warn for fallback, console.log for recovery attempts and success)
    ✅ Retries database connection periodically (configurable interval, default 60 seconds, unlimited retries)
- **6.4** Add comprehensive error handling (COMPLETED)
  - Implemented comprehensive error handling for all database operations with specific error types and structured logging
  - Custom Error Classes Created:
    * DatabaseOperationError: Base class for all database operation errors with operation name and cause
    * DatabaseConnectionError: For connection failures with database type tracking
    * DatabaseQueryError: For query execution failures with query type and table information
    * DatabaseConstraintError: For constraint violations (unique, foreign key, etc.) with constraint name and table
    * ValidationError: For input validation failures with field name and value
  - Error Handling Infrastructure:
    * Created withErrorHandling() helper function that wraps all database operations
    * Automatic error type detection and categorization based on error messages
    * Structured error logging with timestamps, operation names, and context
    * Security: API keys truncated in logs (first 10 chars only) to prevent sensitive data leakage
  - Error Logging Format:
    * [DB Connection Error] - for connection issues
    * [DB Constraint Error] - for constraint violations
    * [Validation Error] - for validation failures
    * [DB Operation Error] - for general database errors
    * Each log entry includes: timestamp, operation, errorType, errorMessage, and context
  - Functions Updated with Error Handling:
    * findApiKey() - Added validation for empty keys and error logging
    * createApiKey() - Added constraint error detection for duplicate keys
    * updateApiKey() - Added validation for update fields (name, token limit, expiry date)
    * deleteApiKey() - Added proper error handling with context
    * updateApiKeyUsage() - Added validation for negative tokens and error logging for missing keys
    * getKeyStats() - Added error handling with context
    * getAllApiKeys() - Added parameter validation (limit, offset)
    * findKeysByModel() - Added validation for model parameter
    * findExpiredKeys() - Added error logging with timestamp
    * findActiveKeys() - Added error logging with timestamp
  - Testing:
    * All 34 database operations tests passing
    * Error logging verified through console output during test runs
    * No regressions in existing functionality
    * Error type detection tested (validation errors, constraint errors, query errors)
  - Code Quality:
    * Follows existing code patterns and conventions
    * No console.log statements (only structured error logging with console.error and console.warn)
    * Comprehensive JSDoc documentation for all error classes and helper functions
    * TypeScript type safety maintained with proper error type checking
    * ESLint validation passed
  - Modified Files:
    * src/db/operations.ts: Added error classes, withErrorHandling helper, updated all functions
  - All acceptance criteria met:
    ✅ Specific error types (connection, query, constraint, validation)
    ✅ Meaningful error messages with context (operation, field, value)
    ✅ Structured error logging (timestamp, error type, context)
    ✅ User-friendly error responses (clear action messages)

