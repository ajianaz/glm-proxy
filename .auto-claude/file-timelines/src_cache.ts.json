{
  "file_path": "src/cache.ts",
  "main_branch_history": [],
  "task_views": {
    "006-implement-in-memory-api-key-cache-with-ttl-to-elim": {
      "task_id": "006-implement-in-memory-api-key-cache-with-ttl-to-elim",
      "branch_point": {
        "commit_hash": "e4ccb2c239067a08687940247e7dc3c37228e546",
        "content": "",
        "timestamp": "2026-01-22T13:20:55.122162"
      },
      "worktree_state": {
        "content": "/**\n * LRU Cache with TTL support\n *\n * Implements an in-memory LRU (Least Recently Used) cache with configurable\n * TTL (Time-To-Live) to cache API keys and eliminate file I/O overhead.\n */\n\n/**\n * Cache entry containing value, timestamp, and TTL\n */\ninterface CacheEntry<T> {\n  /** The cached value (can be null for not-found keys) */\n  value: T | null;\n  /** Unix timestamp when this entry was created/updated (milliseconds) */\n  timestamp: number;\n  /** Time-to-live in milliseconds */\n  ttl: number;\n}\n\n/**\n * Node for doubly-linked list used in LRU tracking\n */\ninterface LRUNode {\n  key: string;\n  prev: LRUNode | null;\n  next: LRUNode | null;\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  /** Number of successful cache retrievals */\n  hits: number;\n  /** Number of cache misses (not found or expired) */\n  misses: number;\n  /** Hit rate as percentage (0-100) */\n  hitRate: number;\n  /** Current number of entries */\n  size: number;\n  /** Maximum number of entries allowed */\n  maxSize: number;\n}\n\n/**\n * LRU Cache interface\n */\nexport interface LRUCache<T> {\n  /**\n   * Retrieve a value from cache by key.\n   * Returns null if key doesn't exist or entry has expired.\n   * Updates the entry's \"recently used\" status on hit.\n   */\n  get(key: string): T | null;\n\n  /**\n   * Store a value in cache with optional TTL override.\n   * If key exists, updates value and timestamp.\n   * If cache is full, evicts least recently used entry.\n   */\n  set(key: string, value: T | null, ttl?: number): void;\n\n  /**\n   * Check if a key exists in cache (without retrieving).\n   * Returns false for expired entries.\n   */\n  has(key: string): boolean;\n\n  /**\n   * Delete a specific entry from cache.\n   * No-op if key doesn't exist.\n   */\n  delete(key: string): void;\n\n  /**\n   * Clear all entries from cache.\n   * Resets statistics but preserves configuration.\n   */\n  clear(): void;\n\n  /**\n   * Get current cache size (number of entries).\n   */\n  readonly size: number;\n\n  /**\n   * Get maximum cache size limit.\n   */\n  readonly maxSize: number;\n\n  /**\n   * Get cache statistics (hits, misses, hit rate).\n   */\n  getStats(): CacheStats;\n\n  /**\n   * Reset statistics counters (for testing).\n   */\n  resetStats(): void;\n}\n\n/**\n * LRU Cache implementation\n */\nclass LRUCacheImpl<T> implements LRUCache<T> {\n  private cache: Map<string, CacheEntry<T>>;\n  private lruMap: Map<string, LRUNode>;\n  private head: LRUNode | null = null;\n  private tail: LRUNode | null = null;\n  private hits: number = 0;\n  private misses: number = 0;\n  private _size: number = 0;\n\n  constructor(\n    public readonly maxSize: number = 1000,\n    private defaultTTL: number = 300000 // 5 minutes\n  ) {\n    this.cache = new Map();\n    this.lruMap = new Map();\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Check if entry has expired based on TTL\n   */\n  private isExpired(entry: CacheEntry<T>): boolean {\n    const now = Date.now();\n    return (now - entry.timestamp) > entry.ttl;\n  }\n\n  /**\n   * Move a node to the front of the LRU list (most recently used)\n   */\n  private moveToFront(key: string): void {\n    const node = this.lruMap.get(key);\n    if (!node) return;\n\n    // Remove node from current position\n    if (node.prev) {\n      node.prev.next = node.next;\n    } else {\n      // Node is already at head\n      return;\n    }\n\n    if (node.next) {\n      node.next.prev = node.prev;\n    } else {\n      // Node is tail, update tail\n      this.tail = node.prev;\n    }\n\n    // Add node to front\n    node.prev = null;\n    node.next = this.head;\n\n    if (this.head) {\n      this.head.prev = node;\n    }\n\n    this.head = node;\n\n    // If this was the only node, update tail\n    if (!this.tail) {\n      this.tail = node;\n    }\n  }\n\n  /**\n   * Add a new node to the front of the LRU list\n   */\n  private addToFront(key: string): void {\n    const node: LRUNode = {\n      key,\n      prev: null,\n      next: this.head,\n    };\n\n    this.lruMap.set(key, node);\n\n    if (this.head) {\n      this.head.prev = node;\n    }\n\n    this.head = node;\n\n    // If this is the first node, update tail\n    if (!this.tail) {\n      this.tail = node;\n    }\n  }\n\n  /**\n   * Remove a node from the LRU list\n   */\n  private removeNode(node: LRUNode): void {\n    if (node.prev) {\n      node.prev.next = node.next;\n    } else {\n      this.head = node.next;\n    }\n\n    if (node.next) {\n      node.next.prev = node.prev;\n    } else {\n      this.tail = node.prev;\n    }\n\n    this.lruMap.delete(node.key);\n  }\n\n  /**\n   * Evict the least recently used entry (tail of LRU list)\n   */\n  private evictLRU(): void {\n    if (this.tail) {\n      this.cache.delete(this.tail.key);\n      this.removeNode(this.tail);\n      this._size--;\n    }\n  }\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      this.misses++;\n      return null;\n    }\n\n    // Check if entry has expired\n    if (this.isExpired(entry)) {\n      this.delete(key);\n      this.misses++;\n      return null;\n    }\n\n    this.hits++;\n    this.moveToFront(key);\n    return entry.value;\n  }\n\n  set(key: string, value: T | null, ttl?: number): void {\n    // Check if key already exists\n    const existing = this.cache.get(key);\n\n    if (existing) {\n      // Update existing entry\n      existing.value = value;\n      existing.timestamp = Date.now();\n      existing.ttl = ttl ?? this.defaultTTL;\n      this.moveToFront(key);\n      return;\n    }\n\n    // Evict LRU if cache is full\n    if (this._size >= this.maxSize) {\n      this.evictLRU();\n    }\n\n    // Add new entry\n    const entry: CacheEntry<T> = {\n      value,\n      timestamp: Date.now(),\n      ttl: ttl ?? this.defaultTTL,\n    };\n\n    this.cache.set(key, entry);\n    this.addToFront(key);\n    this._size++;\n  }\n\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      return false;\n    }\n\n    // Check if entry has expired\n    if (this.isExpired(entry)) {\n      this.delete(key);\n      return false;\n    }\n\n    return true;\n  }\n\n  delete(key: string): void {\n    const entry = this.cache.get(key);\n    if (!entry) {\n      return;\n    }\n\n    const node = this.lruMap.get(key);\n    if (node) {\n      this.removeNode(node);\n    }\n\n    this.cache.delete(key);\n    this._size--;\n  }\n\n  clear(): void {\n    this.cache.clear();\n    this.lruMap.clear();\n    this.head = null;\n    this.tail = null;\n    this._size = 0;\n    // Note: we don't reset statistics on clear\n  }\n\n  getStats(): CacheStats {\n    const total = this.hits + this.misses;\n    const hitRate = total > 0 ? (this.hits / total) * 100 : 0;\n\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      hitRate,\n      size: this._size,\n      maxSize: this.maxSize,\n    };\n  }\n\n  resetStats(): void {\n    this.hits = 0;\n    this.misses = 0;\n  }\n}\n\n// Create and export singleton cache instance for API keys\nconst CACHE_TTL_MS = parseInt(process.env.CACHE_TTL_MS || '300000');\nconst CACHE_MAX_SIZE = parseInt(process.env.CACHE_MAX_SIZE || '1000');\n\n/**\n * Singleton cache instance for API keys\n * Imported and used by storage.ts\n */\nexport const apiKeyCache: LRUCache<import('./types.js').ApiKey> = new LRUCacheImpl<import('./types.js').ApiKey>(\n  CACHE_MAX_SIZE,\n  CACHE_TTL_MS\n);\n\nexport { LRUCacheImpl };\n",
        "last_modified": "2026-01-22T13:20:55.577993"
      },
      "task_intent": {
        "title": "Implement in-memory API key cache with TTL to eliminate file I/O on every request",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-22T12:46:07.628725",
  "last_updated": "2026-01-22T13:20:55.428093"
}