{
  "file_path": "test/storage.test.ts",
  "main_branch_history": [],
  "task_views": {
    "006-implement-in-memory-api-key-cache-with-ttl-to-elim": {
      "task_id": "006-implement-in-memory-api-key-cache-with-ttl-to-elim",
      "branch_point": {
        "commit_hash": "e4ccb2c239067a08687940247e7dc3c37228e546",
        "content": "import { describe, it, expect, beforeEach, afterAll } from 'vitest';\nimport { readApiKeys, writeApiKeys } from '../src/storage.js';\nimport { existsSync, unlinkSync } from 'fs';\nimport { join } from 'path';\n\n// Mock DATA_FILE environment variable for tests\nconst TEST_FILE = join(process.cwd(), 'data', 'test-apikeys.json');\n\n// Save original DATA_FILE\nconst originalDataFile = process.env.DATA_FILE;\n\ndescribe('Storage', () => {\n  beforeEach(() => {\n    // Set test data file\n    process.env.DATA_FILE = TEST_FILE;\n\n    // Clean up test file before each test\n    if (existsSync(TEST_FILE)) {\n      unlinkSync(TEST_FILE);\n    }\n  });\n\n  afterAll(() => {\n    // Restore original DATA_FILE\n    process.env.DATA_FILE = originalDataFile;\n\n    // Clean up test file\n    if (existsSync(TEST_FILE)) {\n      unlinkSync(TEST_FILE);\n    }\n  });\n\n  describe('readApiKeys', () => {\n    it('should return empty keys for non-existent file', async () => {\n      const result = await readApiKeys();\n      expect(result.keys).toHaveLength(0);\n    });\n  });\n\n  describe('writeApiKeys and readApiKeys', () => {\n    it('should write and read API keys', async () => {\n      const data = {\n        keys: [\n          {\n            key: 'pk_test',\n            name: 'Test',\n            model: 'glm-4.7',\n            token_limit_per_5h: 100000,\n            expiry_date: '2026-12-31T23:59:59Z',\n            created_at: '2026-01-18T00:00:00Z',\n            last_used: '2026-01-18T00:00:00Z',\n            total_lifetime_tokens: 0,\n            usage_windows: [],\n          },\n        ],\n      };\n\n      await writeApiKeys(data);\n      const read = await readApiKeys();\n\n      expect(read.keys).toHaveLength(1);\n      expect(read.keys[0].key).toBe('pk_test');\n    });\n  });\n});\n",
        "timestamp": "2026-01-22T13:20:55.122162"
      },
      "worktree_state": {
        "content": "import { describe, it, expect, beforeEach, afterAll } from 'vitest';\nimport { readApiKeys, writeApiKeys, findApiKey, updateApiKeyUsage } from '../src/storage.js';\nimport { apiKeyCache } from '../src/cache.js';\nimport { existsSync, unlinkSync } from 'fs';\nimport { join } from 'path';\n\n// Mock DATA_FILE environment variable for tests\nconst TEST_FILE = join(process.cwd(), 'data', 'test-apikeys.json');\n\n// Save original DATA_FILE and CACHE_ENABLED\nconst originalDataFile = process.env.DATA_FILE;\nconst originalCacheEnabled = process.env.CACHE_ENABLED;\n\nconst testApiKey = {\n  key: 'pk_test',\n  name: 'Test',\n  model: 'glm-4.7',\n  token_limit_per_5h: 100000,\n  expiry_date: '2026-12-31T23:59:59Z',\n  created_at: '2026-01-18T00:00:00Z',\n  last_used: '2026-01-18T00:00:00Z',\n  total_lifetime_tokens: 0,\n  usage_windows: [],\n};\n\ndescribe('Storage', () => {\n  const ACTUAL_FILE = join(process.cwd(), 'data', 'apikeys.json');\n\n  beforeEach(() => {\n    // Set test data file\n    process.env.DATA_FILE = TEST_FILE;\n    process.env.CACHE_ENABLED = 'true';\n\n    // Clean up both test file and actual file before each test\n    if (existsSync(TEST_FILE)) {\n      unlinkSync(TEST_FILE);\n    }\n    if (existsSync(ACTUAL_FILE)) {\n      unlinkSync(ACTUAL_FILE);\n    }\n\n    // Clear cache before each test\n    apiKeyCache.clear();\n    apiKeyCache.resetStats();\n  });\n\n  afterAll(() => {\n    // Restore original DATA_FILE and CACHE_ENABLED\n    process.env.DATA_FILE = originalDataFile;\n    process.env.CACHE_ENABLED = originalCacheEnabled;\n\n    // Clean up test file\n    if (existsSync(TEST_FILE)) {\n      unlinkSync(TEST_FILE);\n    }\n  });\n\n  describe('readApiKeys', () => {\n    it('should return empty keys for non-existent file', async () => {\n      const result = await readApiKeys();\n      expect(result.keys).toHaveLength(0);\n    });\n  });\n\n  describe('writeApiKeys and readApiKeys', () => {\n    it('should write and read API keys', async () => {\n      const data = {\n        keys: [testApiKey],\n      };\n\n      await writeApiKeys(data);\n      const read = await readApiKeys();\n\n      expect(read.keys).toHaveLength(1);\n      expect(read.keys[0].key).toBe('pk_test');\n    });\n  });\n\n  describe('findApiKey with cache integration', () => {\n    it('should return null for non-existent key (cache miss and file miss)', async () => {\n      const result = await findApiKey('pk_nonexistent');\n      expect(result).toBeNull();\n    });\n\n    it('should return ApiKey for existing key (cache miss, file hit, cache populate)', async () => {\n      // Write API key to file\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // First call - cache miss, should read from file\n      const result1 = await findApiKey('pk_test');\n      expect(result1).toEqual(testApiKey);\n\n      // Verify cache was populated\n      expect(apiKeyCache.has('pk_test')).toBe(true);\n    });\n\n    it('should return ApiKey from cache on second call (cache hit)', async () => {\n      // Write API key to file\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // First call - populates cache\n      await findApiKey('pk_test');\n\n      // Reset stats to isolate the cache hit test\n      apiKeyCache.resetStats();\n\n      // Second call - should hit cache\n      const result2 = await findApiKey('pk_test');\n      expect(result2).toEqual(testApiKey);\n\n      // Verify cache hit\n      const stats = apiKeyCache.getStats();\n      expect(stats.hits).toBe(1);\n      expect(stats.misses).toBe(0);\n    });\n\n    it('should cache not-found keys as null (negative caching)', async () => {\n      // Ensure no keys in file\n      await writeApiKeys({ keys: [] });\n\n      // First call for non-existent key\n      await findApiKey('pk_nonexistent');\n\n      // Verify null was cached\n      expect(apiKeyCache.has('pk_nonexistent')).toBe(true);\n      expect(apiKeyCache.get('pk_nonexistent')).toBeNull();\n\n      // Reset stats to isolate the second call test\n      apiKeyCache.resetStats();\n\n      // Second call should hit cache (even though returns null)\n      const result2 = await findApiKey('pk_nonexistent');\n      expect(result2).toBeNull();\n\n      const stats = apiKeyCache.getStats();\n      expect(stats.hits).toBe(1); // Second call was a cache hit\n      expect(stats.misses).toBe(0);\n    });\n\n    it('should handle multiple keys with correct cache population', async () => {\n      const apiKey2 = {\n        ...testApiKey,\n        key: 'pk_test2',\n        name: 'Test2',\n      };\n\n      await writeApiKeys({ keys: [testApiKey, apiKey2] });\n\n      // Look up both keys\n      const result1 = await findApiKey('pk_test');\n      const result2 = await findApiKey('pk_test2');\n\n      expect(result1).toEqual(testApiKey);\n      expect(result2).toEqual(apiKey2);\n\n      // Both should be in cache\n      expect(apiKeyCache.has('pk_test')).toBe(true);\n      expect(apiKeyCache.has('pk_test2')).toBe(true);\n      expect(apiKeyCache.size).toBe(2);\n    });\n\n    it('should update cache when API key usage is updated', async () => {\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // First call to populate cache\n      await findApiKey('pk_test');\n\n      // Reset stats to isolate the update behavior\n      apiKeyCache.resetStats();\n\n      // Update usage\n      await updateApiKeyUsage('pk_test', 1000, 'glm-4.7');\n\n      // Get the updated key from cache\n      const updatedKey = await findApiKey('pk_test');\n      expect(updatedKey?.total_lifetime_tokens).toBe(1000);\n      expect(updatedKey?.last_used).not.toBe(testApiKey.last_used);\n\n      // Verify the call hit the cache\n      const stats = apiKeyCache.getStats();\n      expect(stats.hits).toBe(1);\n      expect(stats.misses).toBe(0);\n    });\n\n    it('should work correctly when cache is disabled', async () => {\n      process.env.CACHE_ENABLED = 'false';\n\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // First call\n      const result1 = await findApiKey('pk_test');\n      expect(result1).toEqual(testApiKey);\n\n      // Second call - should still read from file (cache disabled)\n      const result2 = await findApiKey('pk_test');\n      expect(result2).toEqual(testApiKey);\n\n      // Verify apiKeyCache singleton wasn't affected\n      // (it still has entries from previous tests, but findApiKey doesn't use it when disabled)\n      expect(result1).toEqual(testApiKey);\n    });\n\n    it('should handle cache population after file write', async () => {\n      // Start with empty file\n      await writeApiKeys({ keys: [] });\n\n      // Try to find key (miss, cached as null)\n      const result1 = await findApiKey('pk_test');\n      expect(result1).toBeNull();\n      expect(apiKeyCache.has('pk_test')).toBe(true);\n\n      // Now write the key to file\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // Clear the cache entry to simulate fresh lookup\n      apiKeyCache.delete('pk_test');\n\n      // Find again - should read from file and populate cache\n      const result2 = await findApiKey('pk_test');\n      expect(result2).toEqual(testApiKey);\n      expect(apiKeyCache.has('pk_test')).toBe(true);\n    });\n\n    it('should maintain data consistency between cache and file on updates', async () => {\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // Populate cache\n      await findApiKey('pk_test');\n\n      // Update usage multiple times\n      await updateApiKeyUsage('pk_test', 1000, 'glm-4.7');\n      let key = await findApiKey('pk_test');\n      expect(key?.total_lifetime_tokens).toBe(1000);\n\n      await updateApiKeyUsage('pk_test', 500, 'glm-4.7');\n      key = await findApiKey('pk_test');\n      expect(key?.total_lifetime_tokens).toBe(1500);\n\n      // Verify all cache hits after initial population\n      const stats = apiKeyCache.getStats();\n      expect(stats.hits).toBeGreaterThan(0);\n    });\n  });\n\n  describe('updateApiKeyUsage with cache integration', () => {\n    it('should not update cache for non-existent key', async () => {\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // Try to update non-existent key\n      await updateApiKeyUsage('pk_nonexistent', 1000, 'glm-4.7');\n\n      // Should not affect cache\n      expect(apiKeyCache.has('pk_nonexistent')).toBe(false);\n    });\n\n    it('should update usage_windows correctly', async () => {\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // Update usage\n      await updateApiKeyUsage('pk_test', 1000, 'glm-4.7');\n\n      // Get the key\n      const key = await findApiKey('pk_test');\n\n      expect(key?.usage_windows).toHaveLength(1);\n      expect(key?.usage_windows[0].tokens_used).toBe(1000);\n    });\n\n    it('should clean up old usage windows', async () => {\n      const oldDate = new Date(Date.now() - 10 * 60 * 60 * 1000).toISOString(); // 10 hours ago\n      const apiKeyWithOldWindow = {\n        ...testApiKey,\n        usage_windows: [\n          {\n            window_start: oldDate,\n            tokens_used: 5000,\n          },\n        ],\n      };\n\n      await writeApiKeys({ keys: [apiKeyWithOldWindow] });\n\n      // Update usage (should clean old window)\n      await updateApiKeyUsage('pk_test', 1000, 'glm-4.7');\n\n      const key = await findApiKey('pk_test');\n      expect(key?.usage_windows).toHaveLength(1);\n      expect(key?.usage_windows[0].tokens_used).toBe(1000);\n    });\n  });\n\n  describe('Cache statistics tracking', () => {\n    it('should track hits and misses accurately', async () => {\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // Populate cache\n      await findApiKey('pk_test');\n      await findApiKey('pk_nonexistent');\n\n      // Reset stats to start counting from here\n      apiKeyCache.resetStats();\n\n      // Hit - from cache (pk_test)\n      await findApiKey('pk_test');\n\n      // Hit - from negative cache (pk_nonexistent)\n      await findApiKey('pk_nonexistent');\n\n      // One more hit for pk_test\n      await findApiKey('pk_test');\n\n      const stats = apiKeyCache.getStats();\n      expect(stats.hits).toBe(3);\n      expect(stats.misses).toBe(0);\n      expect(stats.hitRate).toBe(100);\n    });\n\n    it('should reset stats correctly', async () => {\n      await writeApiKeys({ keys: [testApiKey] });\n\n      // Populate cache\n      await findApiKey('pk_test');\n\n      // Hit from cache\n      await findApiKey('pk_test');\n\n      let stats = apiKeyCache.getStats();\n      expect(stats.hits).toBe(1);\n      expect(stats.misses).toBe(0);\n\n      apiKeyCache.resetStats();\n\n      stats = apiKeyCache.getStats();\n      expect(stats.hits).toBe(0);\n      expect(stats.misses).toBe(0);\n      expect(stats.size).toBe(1); // Size should remain\n    });\n  });\n});\n",
        "last_modified": "2026-01-22T13:20:55.585476"
      },
      "task_intent": {
        "title": "Implement in-memory API key cache with TTL to eliminate file I/O on every request",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-22T12:46:07.708762",
  "last_updated": "2026-01-22T13:20:55.521391"
}